#include <Rcpp.h>
#include <cstdlib>
#include <cmath>
#include <limits>
#include "helpers.h"
using namespace Rcpp;


// [[Rcpp::export]]
double rnorm_cpp(double mu, double sigma)
{
  const double epsilon = std::numeric_limits<double>::min();
  const double two_pi = 2.0*3.14159265358979323846;

  static double z0, z1;
  static bool generate;
  generate = !generate;

  if (!generate)
    return z1 * sigma + mu;

  double u1, u2;
  do
  {
    u1 = rand() * (1.0 / RAND_MAX);
    u2 = rand() * (1.0 / RAND_MAX);
  }
  while ( u1 <= epsilon );

  z0 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
  z1 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);
  return z0 * sigma + mu;
}


//////////////////////////////////////////////////////////////////////////////
//
//    HELPERS
//
//////////////////////////////////////////////////////////////////////////////


double runf(double a = 0, double b = 1){
  double r = double(std::rand()) / RAND_MAX;
  if(a == 0 && b == 1) return r;
  return r * (b - a) + a;
  }

bool incrCompare_pos(const std::pair<double, std::vector<double> >& firstElem, const std::pair<double, std::vector<double> >& secondElem) {
  return firstElem.first < secondElem.first;
}

bool decrCompare_pos(const std::pair<double, std::vector<double> >& firstElem, const std::pair<double, std::vector<double> >& secondElem) {
  return firstElem.first > secondElem.first;
}

std::vector< std::pair<double, std::vector<double> > > mysort_pos(std::vector< std::pair<double, std::vector<double> > > pairs, bool decreasing = true){
  if(decreasing == true)  std::sort(pairs.begin(), pairs.end(), decrCompare_pos);
  if(decreasing == false) std::sort(pairs.begin(), pairs.end(), incrCompare_pos);
  return pairs;
  }

// [[Rcpp::export]]
std::vector<double> arrange_pos(std::vector<double> opt){
  int i, outn = opt.size() / 3;
  std::pair<double, std::vector<double> > event;
  std::vector< std::pair<double, std::vector<double> > > plus, minus;
  std::vector<double> os, ps, pos, all;
  for(i = 0; i < outn; ++i){
    event.first  = opt[i];
    event.second.push_back(opt[i + outn]);
    event.second.push_back(opt[i + outn*2]);
    if(opt[i] > 0){
      plus.push_back(event);
      } else {
      minus.push_back(event);
      }
    event.second.clear();
    }
  plus  = mysort_pos(plus,true);
  minus = mysort_pos(minus,false);
  std::vector< std::pair<double, std::vector<double> > >::const_iterator it;
  for (it = minus.begin(); it != minus.end(); ++it){
    os.push_back(it->first);
    ps.push_back(it->second[0]);
    pos.push_back(it->second[1]);
  }
  for (it = plus.begin(); it != plus.end(); ++it){
    os.push_back(it->first);
    ps.push_back(it->second[0]);
    pos.push_back(it->second[1]);
  }
  all.insert(all.end(), os.begin(), os.end());
  all.insert(all.end(), ps.begin(), ps.end());
  all.insert(all.end(), pos.begin(), pos.end());
  all.push_back(minus.size());
  return all;
}

// [[Rcpp::export]]
std::vector<double> edit_pos(std::vector<double> ss,
                         NumericVector opt,
                         bool add_n = false,
                         bool do_arrange = true){
  std::map<double, double> tab;
  double unit = 1.0 / ss.size();
  int no = std::floor(opt.size()/2), n = ss.size();
  for(int i = 0; i < no; i++) tab[opt[i]] = 0;
  for(int i = 0; i < n; i++){
    double o = ss[i];
    tab[o] += unit;
    }
  int add = 0;
  if(no > tab.size()) add = no - tab.size();
  std::vector<double> ed_opt;
  std::map<double, double>::const_iterator it;
  for(it = tab.begin(); it != tab.end(); ++it) ed_opt.push_back(it->first);
  for(int i = 0; i < add; i++) ed_opt.push_back(0);
  for(it = tab.begin(); it != tab.end(); ++it) ed_opt.push_back(it->second);
  for(int i = 0; i < add; i++) ed_opt.push_back(0);

  // add pos
  std::vector<double> pos(no, 0.0);
  for(int j = 0; j < no; ++j){
    int ind = 1;
    for(int i = 0; i < n; ++i){
      if(ed_opt[j] == ss[i]){
        //std::cout << ss[i] << '\t' << i << '\n';
        pos[j] += (1.0 / ind) * (i - pos[j]);
        ind ++;
      }
    }
  }
  if(n > 1) {
    for(int j = 0; j < no; ++j) ed_opt.push_back(double(pos[j]) / (n-1));
    } else {
    for(int j = 0; j < no; ++j){
      if(ed_opt[no + j] > 0){
        ed_opt.push_back(.5);
        } else {
        ed_opt.push_back(0);
        }
      }
    }
  if(do_arrange == true) ed_opt = arrange_pos(ed_opt);
  if(add_n == true) ed_opt.push_back(ss.size());

  return ed_opt;
  }

//////////////////////////////////////////////////////////////////////////////
//' Edit experiences
//'
//' \code{edit_exp} converts the collected samples into a problem table of
//'   the same format as the original problem table. See link{p_arrange}.
//'
//' @param ss a list of samples as generated by, e.g., \link{sampl_n}.
//' @param prob a problem table as produced by \link{p_arrange}.
//' @param frequency
//'
//' @return a problem table matching \code{prob}.
//'
//' @export
// [[Rcpp::export]]
GenericVector edit_exp_pos(GenericVector ss,
                       GenericVector prob,
                       bool add_n = false,
                       bool do_arrange = true){
  NumericMatrix As = prob[0];
  NumericMatrix Bs = prob[1];
  int add_col = 0;
  if(add_n == true) add_col = 1;
  int ncolA = As.ncol(), ncolB = Bs.ncol();
  if(do_arrange == false) ncolA--;
  if(do_arrange == false) ncolB--;
  NumericMatrix As_n(As.nrow(),ncolA + add_col + (As.ncol()-1) / 2.0);
  NumericMatrix Bs_n(Bs.nrow(),ncolB + add_col + (Bs.ncol()-1) / 2.0);
  int np = ss.size();
  for(int p = 0; p < np; p++){
    GenericVector oo = ss[p];
    std::vector<double> edA = edit_pos(oo[0],As(p,_),add_n,do_arrange);
    std::vector<double> edB = edit_pos(oo[1],Bs(p,_),add_n,do_arrange);
    int nA = edA.size(), nB = edB.size();
    for(int i = 0; i < nA; i++) As_n(p,i) = edA[i];
    for(int i = 0; i < nB; i++) Bs_n(p,i) = edB[i];
    }
  GenericVector prob_n(2);
  prob_n[0] = As_n;
  prob_n[1] = Bs_n;
  return prob_n;
  }



//////////////////////////////////////////////////////////////////////////////
//' Calculate the utility of an option
//'
//' \code{utility} calculates the utility of an option based on a specific
//'   type of prospect theory. For details see \link{v_wrapper} and
//'   \link{w_wrapper}.
//'
//'
//' @param opt numeric vector specifying the outcomes and probabilities of an
//'   option. The function expects a length of (number of outcomes * 2 + 1),
//'   that is ordered according to max_loss, min_loss, max_gain, min_gain, and
//'   whose last entry indicates the number of loss outcomes.
//' @param par numeric vector specifying the parameters of the CPT model. See
//'   \link{v_wrapper} and \link{v_wrapper}.
//' @param type integer specifying the parameterization of the value and
//'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
//'
//' @return a utility.
//'
//' @export
// [[Rcpp::export]]
double utility_pos(NumericVector opt, std::vector<double> par, int type, double noise_level, double recency){
  int i, n = opt.size(), no = (opt.size() - 2)/3;
  int nneg = opt[n - 2];
  int npos = no - nneg;
  double u, w, nw, rec, noise, ut = 0;
  std::vector<double> us, cmp, ps, po;
  std::vector<int> ns;
  if(nneg > 0){
    for(i = 0; i < nneg; i++){
      u = v_wrapper(opt[i],par,type);
      us.push_back(u);
      ps.push_back(opt[i + no]);
      po.push_back(opt[i + no*2]);
      ns.push_back(opt[i + no] * opt[no*3 + 1]);
      }
    noise = 1;
    if(ns[0] > 0 && noise_level != 0){
      noise = 0;
      for(int j = 0; j < ns[0]; ++j) noise += runf(1 - noise_level/2,1 + noise_level/2);
      noise /= ns[0];
      }
    rec = 1 + (po[0]-.5) * 2 * recency;
    cmp = cump(ps);
    //std::cout << 'n' << '\t' << noise << '\t' << rec << '\n';
    w   = w_wrapper(cmp[0],opt[0], par, type);
    ut += w * us[0] * noise * rec;
    for(i = 1; i < nneg; i++){
      nw = w_wrapper(cmp[i],opt[i], par, type);
      noise = 1;
      if(ns[i] > 0 && noise_level != 0){
        noise = 0;
        for(int j = 0; j < ns[i]; ++j) noise += runf(1 - noise_level/2,1 + noise_level/2);
        noise /= ns[i];
        }
      rec = 1 + (po[i]-.5) * 2 * recency;
      //std::cout << 'n' << '\t' << noise << '\t' << rec << '\n';
      ut += us[i] * (nw - w) * noise * rec;
      w = nw;
      }
    us.clear();
    ps.clear();
    po.clear();
    ns.clear();
    }
  if(npos > 0){
    for(i = 0; i < npos; i++){
      u = v_wrapper(opt[i + nneg],par,type);
      us.push_back(u);
      ps.push_back(opt[i + nneg + no]);
      po.push_back(opt[i + nneg + no*2]);
      ns.push_back(std::round(opt[i + nneg + no] * opt[no*3 + 1]));
      }
    noise = 1;
    if(ns[0] > 0 && noise_level != 0){
      noise = 0;
      for(int j = 0; j < ns[0]; ++j) noise += runf(1 - noise_level/2,1 + noise_level/2);
      noise /= ns[0];
      }
    rec = 1 + (po[0]-.5) * 2 * recency;
    //std::cout << 'p' << '\t' << noise << '\t' << rec <<  '\t' << ns[0] << '\n';
    cmp = cump(ps);
    w   = w_wrapper(cmp[0],opt[nneg], par, type);
    ut += w * us[0] * noise * rec;
    for(i = 1; i < npos; i++){
      nw = w_wrapper(cmp[i],opt[i + nneg], par, type);
      noise = 1;
      if(ns[i] > 0 && noise_level != 0){
        noise = 0;
        for(int j = 0; j < ns[i]; ++j) noise += runf(1 - noise_level/2,1 + noise_level/2);
        noise /= ns[i];
        }
      rec = 1 + (po[i]-.5) * 2 * recency;
      //std::cout << 'p' << '\t' << noise << '\t' << rec << '\t' << ns[i] <<  '\n';
      ut += us[i] * (nw - w) * noise * rec;
      w = nw;
      }
    }
  return ut;
  }

//////////////////////////////////////////////////////////////////////////////
//' CPT-based deterministic choices
//'
//' \code{cpt_choice} produces deterministic choices for a set of choice
//'   problems and parameters.
//'
//' @param par numeric vector specifying the parameters of the CPT model.
//' @param problems a list as generated by \link{p_arrange}.
//' @param type integer specifying the parameterization of the value and
//'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
//'
//' @return a vector of choices
//'
//' @export
// [[Rcpp::export]]
std::vector<int> cpt_choice_pos(std::vector<double> par,
                            GenericVector problems,
                            int type = 000,
                            double noise_level = 0,
                            double recency = 0){
  NumericMatrix As = problems[0], Bs = problems[1];
  int i, n = As.nrow();
  double utA, utB, r;
  NumericVector A, B;
  std::vector<int> choices;
  for(i = 0; i < n; i++){
    //cout << llik << "\n";
    A = As(i,_);
    B = Bs(i,_);
    utA = utility_pos(A, par, type, noise_level, recency);
    utB = utility_pos(B, par, type, noise_level, recency);
    if( utA != utB){
      if(utA > utB){
        choices.push_back(0);
      } else {
        choices.push_back(1);
      }
    } else {
      r = double(std::rand()) / RAND_MAX;
      if(r < .5){
        choices.push_back(0);
      } else {
        choices.push_back(1);
      }
    }
  }
  return choices;
}

//////////////////////////////////////////////////////////////////////////////
//
//    NOISE
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//' Get standard deviation
//'
//' \code{getSD} iterates over the samples of a problem and returns the
//'   standard for the problem (relative to mean of all outcomes across
//'   both problems).
//'
//' @param ss numeric specifying the to be transformed probability.
//'
//' @return the standard deviation of the problem.
//'
//' @export
// [[Rcpp::export]]
NumericVector getSD(GenericVector ss){
    int p,np, n;
    double sm, var;
    np = ss.size();
    GenericVector so;
    NumericVector s0, s1;
    NumericVector sds(np);
    for(p = 0; p < np; p++){
      so = ss[p];
      s0 = so[0];
      s1 = so[1];
      n = s0.size();
      sm = 0;
      for(int i = 0; i < n; i++){
        sm += s0[i];
        sm += s1[i];
        }
      sm = sm / (double(n) * 2.0);
      var = 0;
      for(int i = 0; i < n; i++){
        var += (s0[i] - sm) * (s0[i] - sm);
        var += (s1[i] - sm) * (s1[i] - sm);
        }
      sds[p] = std::sqrt(var / double(n * 2 - 1));
      }
    return sds;
    }


//////////////////////////////////////////////////////////////////////////////
//' Add noise to experienced samples.
//'
//' \code{addNoise} takes the sampled and edited and adds noise based on the
//'   prevalence reconstructed from the sample size and probability to each
//'   of the outcomes based on the provided standard deviation and \code{k}.
//'
//' @param problems edited experiences as provided by \link{editExp}.
//' @param size vector of integer specifying the sample size for each of the
//'   problems.
//' @param sds vector of doubles specifying the standard deviation for each
//'   of the problems.
//' @param k double specifying a multiplicative factor of the standard
//'   deviation.
//'
//' @return problems with added noise
//'
//' @export
// [[Rcpp::export]]
NumericMatrix addNoise(GenericVector problems, std::vector<double> sds, double k){
  GenericVector problems_n(2);
  NumericMatrix As = problems[0], Bs = problems[1];
  int np = As.nrow();
  NumericVector A0 = As(0,_), B0 = Bs(0,_);
  int A_nout = (A0.size() - 1) / 2;
  int B_nout = (B0.size() - 1) / 2;
  NumericMatrix probs(np,A_nout * 2 + B_nout * 2);
  for(int p = 0; p < np; p++){
    NumericVector A = As(p,_), B = Bs(p,_);
    int size = A[A_nout * 2];
    for(int i = 0; i < A_nout; i++){
      double n = std::round(A[A_nout + i] * double(size));
      double noise = 0;
      for(int j = 0; j < int(n); j++){
        noise += rnorm_cpp(0,sds[p] * k);
        }
      if(int(n) > 0){
        probs(p,i) = A[i] + noise / n;
        } else {
        probs(p,i) = A[i];
        }
      probs(p,A_nout + i) = A[A_nout + i];
      }
    for(int i = 0; i < B_nout; i++){
      double n = std::round(B[B_nout + i] * double(size));
      double noise = 0;
      for(int j = 0; j < int(n); j++){
        noise += rnorm_cpp(0,sds[p] * k);
        }
      if(int(n) > 0){
        probs(p,A_nout * 2 + i) = B[i] + noise / n;
        } else {
        probs(p,A_nout * 2 + i) = B[i];
        }
      probs(p,A_nout * 2 + B_nout + i) = B[B_nout + i];
      }
    }
  return probs;
  }

//////////////////////////////////////////////////////////////////////////////
//' Add noise to experienced samples.
//'
//' \code{addNoise} takes the sampled and edited and adds noise based on the
//'   prevalence reconstructed from the sample size and probability to each
//'   of the outcomes based on the provided standard deviation and \code{k}.
//'
//' @param problems edited experiences as provided by \link{editExp}.
//' @param size vector of integer specifying the sample size for each of the
//'   problems.
//' @param sds vector of doubles specifying the standard deviation for each
//'   of the problems.
//' @param k double specifying a multiplicative factor of the standard
//'   deviation.
//'
//' @return problems with added noise
//'
//' @export
// [[Rcpp::export]]
NumericMatrix addPositionWeighting(GenericVector problems, double phi, std::vector<double> sds, double k){
  GenericVector problems_n(2);
  NumericMatrix As = problems[0], Bs = problems[1];
  int np = As.nrow();
  NumericVector A0 = As(0,_), B0 = Bs(0,_);
  int A_nout = (A0.size() - 1) / 3;
  int B_nout = (B0.size() - 1) / 3;
  NumericMatrix probs(np,A_nout * 2 + B_nout * 2);
  for(int p = 0; p < np; p++){
    NumericVector A = As(p,_), B = Bs(p,_);
    int size = A[A_nout * 2];

    // noise option A
    for(int i = 0; i < A_nout; i++){
      double n = std::round(A[A_nout + i] * double(size));
      double noise = 0;
      for(int j = 0; j < int(n); j++){
        noise += rnorm_cpp(0,sds[p] * k);
        }
      std::cout << 0 << '\t' << noise << '\n';
      if(int(n) > 0){
        probs(p,i) = A[i] + noise / n;
        } else {
        probs(p,i) = A[i];
        }
      probs(p,A_nout + i) = A[A_nout + i];
      }

    // noise option B
    for(int i = 0; i < B_nout; i++){
      double n = std::round(B[B_nout + i] * double(size));
      double noise = 0;
      for(int j = 0; j < int(n); j++){
        noise += rnorm_cpp(0,sds[p] * k);
        }
      std::cout << 1 << '\t' << noise << '\n';
      if(int(n) > 0){
        probs(p,A_nout * 2 + i) = B[i] + noise / n;
        } else {
        probs(p,A_nout * 2 + i) = B[i];
        }
      probs(p,A_nout * 2 + B_nout + i) = B[B_nout + i];
      }

    // position A
    for(int i = 0; i < A_nout; i++){
      if(probs(p,i) != 0) probs(p,i) += phi * sds[p] * A[A_nout * 2 + 1 + i];
      }

    // position B
    for(int i = 0; i < B_nout; i++){
      if(probs(p,A_nout * 2 + i) != 0) probs(p,A_nout * 2 + i) += phi * sds[p] * B[A_nout * 2 + 1 + i];
      }
    }

  return probs;
  }



// //////////////////////////////////////////////////////////////////////////////
// //' Edit experiences
// //'
// //' \code{edit_exp} converts the collected samples into a problem table of
// //'   the same format as the original problem table. See link{p_arrange}.
// //'
// //' @param ss a list of samples as generated by, e.g., \link{sampl_n}.
// //' @param prob a problem table as produced by \link{p_arrange}.
// //' @param frequency
// //'
// //' @return a problem table matching \code{prob}.
// //'
// //' @export
// // [[Rcpp::export]]
// GenericVector edit_exp(GenericVector ss, GenericVector prob, bool add_n = false, bool do_arrange = true){
//   int add_col = 0;
//   if(add_n == true) add_col = 1;
//   NumericMatrix As = prob[0];
//   NumericMatrix Bs = prob[1];
//   NumericMatrix As_n(As.nrow(),As.ncol() + add_col);
//   NumericMatrix Bs_n(Bs.nrow(),Bs.ncol() + add_col);
//   int np = ss.size();
//   for(int p = 0; p < np; p++){
//     GenericVector oo = ss[p];
//     std::vector<double> edA = edit_pos(oo[0],As(p,_),add_n,do_arrange);
//     std::vector<double> edB = edit_pos(oo[1],Bs(p,_),add_n,do_arrange);
//     int nA = edA.size(), nB = edB.size();
//     for(int i = 0; i < nA; i++) As_n(p,i) = edA[i];
//     for(int i = 0; i < nB; i++) Bs_n(p,i) = edB[i];
//   }
//   GenericVector prob_n(2);
//   prob_n[0] = As_n;
//   prob_n[1] = Bs_n;
//   return prob_n;
// }
//
//
//
//
//
//
//
