# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Standard value function
#'
#' \code{v}, being the standard value function, transforms the magnitute of
#'   an outcome into utility space
#'   jk
#'
#' @param out numeric specifying the magnitude of the to be transformed
#'   outcome
#' @param alpha numeric specifying the exponent of the utility function for
#'   the gain domain.
#' @param beta numeric specifying the exponent of the utility function for
#'   the loss domain.
#' @param lambda numeric specifying the slope of the utility function for
#'   the loss domain relative to the gain domain.
#'
#' @return a utility
#'
#' @export
v <- function(o, alpha, beta, lambda) {
    .Call('choicepp_v', PACKAGE = 'choicepp', o, alpha, beta, lambda)
}

#' Wrapper for value function
#'
#' \code{v_wrapper} is a wrapper for different parameterizations of the value
#'   function.
#'
#' The type argument controls the type of value function implemented.
#'   - type = xx1 implements only \code{alpha}
#'   - type = xx2 implements \code{alpha} and \code{beta}
#'   - type = xx3 implements \code{alpha}, \code{beta}, and \code{lambda}
#'
#' @param o numeric specifying the to be transformed outcome.
#' @param type integer specifying the parameterization of the value function.
#'   See Details.
#'
#' @return a utility
#'
#' @export
v_wrapper <- function(o, par, type) {
    .Call('choicepp_v_wrapper', PACKAGE = 'choicepp', o, par, type)
}

#' Weighting function according to Tversky & Kahneman (1992)
#'
#' \code{w_tk} is the weighting function proposed by Tverksy & Kahneman
#'   (1992). It transforms probabilities into decision weights.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param gamma_l,gamma_g numeric specifying the exponential factor
#'   (sensitivity) of the weighting function for the loss (l) and gain
#'   (g) domain.
#'
#' @return a decision weight
#'
#' @references Tversky, A., & Kahneman, D. (1992). Advances in prospect
#'   theory: Cumulative representation of uncertainty. Journal of Risk and
#'   uncertainty, 5(4), 297-323.
#'
#' @export
w_tk <- function(p, o, gamma_l, gamma_g) {
    .Call('choicepp_w_tk', PACKAGE = 'choicepp', p, o, gamma_l, gamma_g)
}

#' Weighting function according to Goldstein & Einhorn (1987)
#'
#' \code{w_ge} is the weighting function proposed by Goldstein & Einhorn
#'   (1987). It transforms probabilities into decision weights.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param delta_l,delta_g numeric specifying the multiplicative factor
#'   (elevation) of the weighting function for the loss (l) and gain
#'   (g) domain.
#' @param gamma_l,gamma_g numeric specifying the exponential factor
#'   (sensitivity) of the weighting function for the loss (l) and gain
#'   (g) domain.
#'
#' @return a decision weight
#'
#' @references Goldstein, W. M. and Einhorn, H. J. (1987). Expression Theory
#'   and the Preference Reversal Phenomena. Psychological Review 94, 236—254.
#'
#' @export
w_ge <- function(p, o, delta_l, delta_g, gamma_l, gamma_g) {
    .Call('choicepp_w_ge', PACKAGE = 'choicepp', p, o, delta_l, delta_g, gamma_l, gamma_g)
}

#' Weighting function according to Prelec (1998)
#'
#' \code{w_p} is the weighting function proposed by Tverksy & Kahneman
#'   (1992). It transforms probabilities into decision weights.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param gamma_l,gamma_g numeric specifying the exponential factor
#'   (sensitivity) of the weighting function for the loss (l) and gain
#'   (g) domain.
#'
#' @return a decision weight
#'
#' @references Prelec, D. (1998). The probability weighting function.
#'   Econometrica 66, 497–527.
#'
#' @export
w_p <- function(p, o, delta_l, gamma_l, delta_g, gamma_g) {
    .Call('choicepp_w_p', PACKAGE = 'choicepp', p, o, delta_l, gamma_l, delta_g, gamma_g)
}

#' Wrapper for weighting function
#'
#' \code{w_wrapper} is a wrapper for different parameterizations of the
#'   weighting function.
#'
#' The type argument controls the type of weighting function implemented.
#'   - type = 00x implements the weighting function of Tversky & Kahneman
#'     (1992) with one \code{gamma}.
#'   - type = 01x implements the weighting function of Tversky & Kahneman
#'     (1992) with one \code{gamma} for losses and one \code{gamma} for gains.
#'   - type = 10x implements the weighting function of Goldstein & Einhorn
#'     (1987) with one \code{delta and one \code{gamma}.
#'   - type = 11x implements the weighting function of Goldstein & Einhorn
#'     (1987) with one \code{delta}, one \code{gamma} for losses, and one
#'     \code{gamma} for gains.
#'   - type = 12x implements the weighting function of Goldstein & Einhorn
#'     (1987) with one \code{delta} for losses, one \code{delta} for gains,
#'     and one \code{gamma}.
#'   - type = 13x implements the weighting function of Goldstein & Einhorn
#'     (1987) with one \code{delta} for losses, one \code{delta} for gains,
#'     and one \code{gamma} for losses and one \code{gamma} for gains.
#'   - type = 20x implements the "one"-parameter weighting function of Prelec
#'     (1998) with one \code{gamma}.
#'   - type = 21x implements the "one"-parameter weighting function of Prelec
#'     (1998) with one \code{gamma} for losses and one \code{gamma} for gains.
#'   - type = 22x implements the "two"-parameter weighting function of Prelec
#'     (1998) with one \delta{delta} and one \code{gamma}.
#'   - type = 23x implements the "two"-parameter weighting function of Prelec
#'     (1998) with one \delta{delta}, one \code{gamma} losses, and one
#'     \code{gamma} for gains.
#'     (1998) with one \delta{delta} for losses, one \code{delta} gains, and
#'     one \code{gamma}.
#'     (1998) with one \delta{delta} for losses, one \code{delta} gains, one
#'     \code{gamma} for losses and one \code{gamma} for gains.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param o numeric specifying the outcome associated with the probability.
#' @param type integer specifying the parameterization of the weighting
#'   function. See Details.
#'
#' @return a decision weight
#'
#' @export
w_wrapper <- function(p, o, par, type) {
    .Call('choicepp_w_wrapper', PACKAGE = 'choicepp', p, o, par, type)
}

#' Calculate the utility of an option
#'
#' \code{utility} calculates the utility of an option based on a specific
#'   type of prospect theory. For details see \link{v_wrapper} and
#'   \link{w_wrapper}.
#'
#'
#' @param opt numeric vector specifying the outcomes and probabilities of an
#'   option. The function expects a length of (number of outcomes * 2 + 1),
#'   that is ordered according to max_loss, min_loss, max_gain, min_gain, and
#'   whose last entry indicates the number of loss outcomes.
#' @param par numeric vector specifying the parameters of the CPT model. See
#'   \link{v_wrapper} and \link{v_wrapper}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a utility.
#'
#' @export
utility <- function(opt, par, type) {
    .Call('choicepp_utility', PACKAGE = 'choicepp', opt, par, type)
}

#' Exponential choice rule
#'
#' \code{choice_rule} calculates the probability of choosing A using an ex-
#'   ponential choice rule.
#'
#' @param utA numeric specifying the utility of option A
#' @param utB numeric specifying the utility of option B
#' @param phi numeric specifying the choice sensitivity
#'
#' @return a choice probability
#'
#' @export
choice_rule <- function(utA, utB, phi) {
    .Call('choicepp_choice_rule', PACKAGE = 'choicepp', utA, utB, phi)
}

#' CPT-based choice probabilities
#'
#' \code{cpt_prob} computes for a set of choice problems and a set of
#'   parameters the respective probabilities of choosing option A.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a vector of choice probabilities
#'
#' @export
cpt_prob <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_prob', PACKAGE = 'choicepp', par, problems, type)
}

#' CPT-based likelihood
#'
#' \code{cpt_prob} computes for a set of choice problems and a set of
#'   parameters the combined (negative) log-likelihood of a set of choices.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems list as generated by \link{p_arrange}.
#' @param choices numeric vector of 0s and 1s indicating the choices where
#'   0 = A and 0 = B.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a vector of choice probabilities
#'
#' @export
cpt_lik <- function(par, problems, choices, type = 000L, limit = .0001) {
    .Call('choicepp_cpt_lik', PACKAGE = 'choicepp', par, problems, choices, type, limit)
}

#' CPT-based deterministic choices
#'
#' \code{cpt_choice} produces deterministic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a vector of choices
#'
#' @export
cpt_choice <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_choice', PACKAGE = 'choicepp', par, problems, type)
}

#' CPT-based probabilistic choices
#'
#' \code{cpt_rndchoice} produces probabilistic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a vector of choices
#'
#' @export
cpt_rndchoice <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_rndchoice', PACKAGE = 'choicepp', par, problems, type)
}

#' Test for 1st order stochastic dominance
#'
#' \code{stdom1} tests if one of two problems is stochastically dominant
#'   according to 1st order stochastic dominance.
#'
#' @param A numeric vector containing the outcomes and probabilities
#'   (in that order) of option A
#' @param B numeric vector containing the outcomes and probabilities
#'   (in that order) of option B
#'
#' @return A boolean indicating the status of 1st order stochastic dominance
#'
#' @export
stdom1 <- function(oA, pA, oB, pB) {
    .Call('choicepp_stdom1', PACKAGE = 'choicepp', oA, pA, oB, pB)
}

#' Test for 2nd order stochastic dominance
#'
#' \code{stdom2} tests if one of two problems is stochastically dominant
#'   according to 2nd order stochastic dominance.
#'
#' @param A numeric vector containing the outcomes and probabilities
#'   (in that order) of option A
#' @param B numeric vector containing the outcomes and probabilities
#'   (in that order) of option B
#'
#' @return A boolean indicating the status of 2nd order stochastic dominance
#'
#' @export
stdom2 <- function(oA, pA, oB, pB, d_crit = 0) {
    .Call('choicepp_stdom2', PACKAGE = 'choicepp', oA, pA, oB, pB, d_crit)
}

#' Generate random decision environments
#'
#' \code{pgen_rnd} generates random environments of twp-option choice
#'   problems without 1st and 2nd order stochastic dominance and an
#'   ecologically
#'
#' @param ns integer vector of length three specifying the number of choice
#'   problems in the domain of Gain, Loss, and Mixed (in that order).
#' @param nA integer specifying the number of outcomes in option A
#' @param nB integer specifying the number of outcomes in option B
#' @param lower integer specifying the lower limit of the outcome range
#' @param upper integer specifying the upper limit of the outcome range
#' @param ecological bool specifies whether the outomes should be re-
#'   arranged such that high outcomes are coupled with low probabilities
#' @param stdom1_test bool specifies wehther the function controls for 1st oder
#'   stochastic dominance. If true, only non-dominant problems will be
#'   returned.
#' @param stdom1_test bool specifies wehther the function controls for 2nd oder
#'   stochastic dominance. If true, only non-dominant problems will be
#'   returned.
#' @param d_crit double specifiying the maximum effect size between the options.
#'     I.e., a d_crit value of .5 implies that options differences in
#'     expected values is at most .5 times the pooled standard deviation.
#'
#' @return A matrix of choice problems
#'
#' @export
pgen_rnd <- function(ns, nA = 2L, nB = 2L, lower = -100, upper = 100, ecological = TRUE, stdom1_test = TRUE, stdom2_test = TRUE, d_crit = .5) {
    .Call('choicepp_pgen_rnd', PACKAGE = 'choicepp', ns, nA, nB, lower, upper, ecological, stdom1_test, stdom2_test, d_crit)
}

#' Rearrange problems
#'
#' \code{p_arrange} rearranges the matrix of problem to match the cumulative and
#'   decumulative specifications of CPT and TAX
#'
#' @param problems np x (2*nA + 2*nB) matrix containing the np problems each
#'   having nA and nB outcomes.
#' @param nA number of outcomes in option A
#'
#' @return a list of two matrices containing the outcomes and probabilities of
#'   the A and B options rearranged for CPT and TAX.
#'
#' @export
p_arrange <- function(problems, nA = 0L) {
    .Call('choicepp_p_arrange', PACKAGE = 'choicepp', problems, nA)
}

smpl <- function(opt) {
    .Call('choicepp_smpl', PACKAGE = 'choicepp', opt)
}

smpl_f <- function(opt) {
    .Call('choicepp_smpl_f', PACKAGE = 'choicepp', opt)
}

smpl_n <- function(opt, n) {
    .Call('choicepp_smpl_n', PACKAGE = 'choicepp', opt, n)
}

#' Sample a fixed number of outcomes per option
#'
#' \code{sampl_n} draws a fixed number of samples for each option in the
#'   set of problems.
#'
#' @param prob a problem table as generated by \link{pgen_rnd}.
#' @param ns numceric vector whose length is either one or the number of
#'   problems in the set.
#'
#' @return a list of samples.
#'
#' @export
sampl_n <- function(prob, ns) {
    .Call('choicepp_sampl_n', PACKAGE = 'choicepp', prob, ns)
}

edit1 <- function(ss, size = 0L) {
    .Call('choicepp_edit1', PACKAGE = 'choicepp', ss, size)
}

edit2 <- function(ss, opt) {
    .Call('choicepp_edit2', PACKAGE = 'choicepp', ss, opt)
}

#' Edit experiences
#'
#' \code{edit_exp} converts the collected samples into a problem table of
#'   the same format as the original problem table. See link{pgen_rnd}.
#'
#' @param ss a list of samples as generated by, e.g., \link{sampl_n}.
#' @param prob a problem table as generated by \link{pgen_rnd}.
#'
#' @return a problem table matching \code{prob}.
#'
#' @export
edit_exp <- function(ss, prob) {
    .Call('choicepp_edit_exp', PACKAGE = 'choicepp', ss, prob)
}

