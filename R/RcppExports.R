# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Probability of choosing EV
#'
#' Function calculates the probability of choosing EV for a given a
#' binary problem (between options with maximally 2 outcomes) and sample size based
#' on a strategy that chooses the options with the higher experienced mean.
#'
#' @param p numeric vector containing the outcomes of A, the respective probabilities
#'   of the outcomes of A, the outcomes of B, and the respective probabilities of the
#'   outcomes of B.
#' @param n integer specifying the sample size in terms of the number of samples taken
#'   from \emph{each} of the options.
#'
#' @return a numeric value specifying the probability of choosing the higher EV option.
#'
#' @export
pevbyn_nm <- function(p, n) {
    .Call('choicepp_pevbyn_nm', PACKAGE = 'choicepp', p, n)
}

#' Standard value function
#'
#' \code{v}, being the standard value function, transforms the magnitute of
#'   an outcome into utility space
#'
#' @param o numeric specifying the magnitude of the to be transformed
#'   outcome
#' @param alpha numeric specifying the exponent of the utility function for
#'   the gain domain.
#' @param beta numeric specifying the exponent of the utility function for
#'   the loss domain.
#' @param lambda numeric specifying the slope of the utility function for
#'   the loss domain relative to the gain domain.
#'
#' @return a utility
#'
#' @export
v <- function(o, alpha, beta, lambda) {
    .Call('choicepp_v', PACKAGE = 'choicepp', o, alpha, beta, lambda)
}

#' Wrapper for value function
#'
#' \code{v_wrapper} is a wrapper for different parameterizations of the value
#'   function.
#'
#' @details
#' The type argument controls the type of value function implemented.
#'
#' xx0 implements only \code{alpha}
#'
#' xx1 implements \code{alpha} and \code{lambda}
#'
#' xx2 implements \code{alpha} and \code{beta}
#'
#' xx3 implements \code{alpha}, \code{beta}, and \code{lambda}
#'
#' @param o numeric specifying the to be transformed outcome.
#' @param type integer specifying the parameterization of the value function.
#'   See Details.
#'
#' @return a utility
#'
#' @export
v_wrapper <- function(o, par, type) {
    .Call('choicepp_v_wrapper', PACKAGE = 'choicepp', o, par, type)
}

#' Weighting function according to Tversky & Kahneman (1992)
#'
#' \code{w_tk} is the weighting function proposed by Tverksy & Kahneman
#'   (1992). It transforms probabilities into decision weights.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param gamma_l,gamma_g numeric specifying the exponential factor
#'   (sensitivity) of the weighting function for the loss (l) and gain
#'   (g) domain.
#'
#' @return a decision weight
#'
#' @references Tversky, A., & Kahneman, D. (1992). Advances in prospect
#'   theory: Cumulative representation of uncertainty. Journal of Risk and
#'   uncertainty, 5(4), 297-323.
#'
#' @export
w_tk <- function(p, o, gamma_l, gamma_g) {
    .Call('choicepp_w_tk', PACKAGE = 'choicepp', p, o, gamma_l, gamma_g)
}

#' Weighting function according to Goldstein & Einhorn (1987)
#'
#' \code{w_ge} is the weighting function proposed by Goldstein & Einhorn
#'   (1987). It transforms probabilities into decision weights.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param delta_l,delta_g numeric specifying the multiplicative factor
#'   (elevation) of the weighting function for the loss (l) and gain
#'   (g) domain.
#' @param gamma_l,gamma_g numeric specifying the exponential factor
#'   (sensitivity) of the weighting function for the loss (l) and gain
#'   (g) domain.
#'
#' @return a decision weight
#'
#' @references Goldstein, W. M. and Einhorn, H. J. (1987). Expression Theory
#'   and the Preference Reversal Phenomena. Psychological Review 94, 236—254.
#'
#' @export
w_ge <- function(p, o, delta_l, delta_g, gamma_l, gamma_g) {
    .Call('choicepp_w_ge', PACKAGE = 'choicepp', p, o, delta_l, delta_g, gamma_l, gamma_g)
}

#' Weighting function according to Prelec (1998)
#'
#' \code{w_p} is the weighting function proposed by Tverksy & Kahneman
#'   (1992). It transforms probabilities into decision weights.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param gamma_l,gamma_g numeric specifying the exponential factor
#'   (sensitivity) of the weighting function for the loss (l) and gain
#'   (g) domain.
#'
#' @return a decision weight
#'
#' @references Prelec, D. (1998). The probability weighting function.
#'   Econometrica 66, 497–527.
#'
#' @export
w_p <- function(p, o, delta_l, gamma_l, delta_g, gamma_g) {
    .Call('choicepp_w_p', PACKAGE = 'choicepp', p, o, delta_l, gamma_l, delta_g, gamma_g)
}

#' Wrapper for weighting function
#'
#' \code{w_wrapper} is a wrapper for different parameterizations of the
#'   weighting function.
#'
#' @details
#' The \code{type} argument controls the type of weighting function implemented.
#'
#' 00x implements the weighting function of Tversky & Kahneman
#' (1992) with one \code{gamma}.
#'
#' 01x implements the weighting function of Tversky & Kahneman
#' (1992) with one \code{gamma} for losses and one \code{gamma} for gains.
#'
#' 10x implements the weighting function of Goldstein & Einhorn
#' (1987) with one \code{delta} and one \code{gamma}.
#'
#' 11x implements the weighting function of Goldstein & Einhorn
#' (1987) with one \code{delta}, one \code{gamma} for losses, and one
#' \code{gamma} for gains.
#'
#' 12x implements the weighting function of Goldstein & Einhorn
#' (1987) with one \code{delta} for losses, one \code{delta} for gains,
#' and one \code{gamma}.
#'
#' 13x implements the weighting function of Goldstein & Einhorn
#' (1987) with one \code{delta} for losses, one \code{delta} for gains,
#' and one \code{gamma} for losses and one \code{gamma} for gains.
#'
#' 20x implements the "one"-parameter weighting function of Prelec
#' (1998) with one \code{gamma}.
#'
#' 21x implements the "one"-parameter weighting function of Prelec
#' (1998) with one \code{gamma} for losses and one \code{gamma} for gains.
#'
#' 22x implements the "two"-parameter weighting function of Prelec
#' (1998) with one \code{delta} and one \code{gamma}.
#'
#' 23x implements the "two"-parameter weighting function of Prelec
#' (1998) with one \code{delta}, one \code{gamma} losses, and one
#' \code{gamma} for gains.
#'
#' 24x implements the "two"-parameter weighting function of Prelec
#' (1998) with one \code{delta} for losses, one \code{delta} gains, and
#' one \code{gamma}.
#'
#' 25x implements the "two"-parameter weighting function of Prelec
#' (1998) with one \code{delta} for losses, one \code{delta} gains, one
#' \code{gamma} for losses and one \code{gamma} for gains.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param o numeric specifying the outcome associated with the probability.
#' @param type integer specifying the parameterization of the weighting
#'   function. See Details.
#'
#' @return a decision weight
#'
#' @export
w_wrapper <- function(p, o, par, type) {
    .Call('choicepp_w_wrapper', PACKAGE = 'choicepp', p, o, par, type)
}

#' Calculate the utility of an option
#'
#' \code{utility} calculates the utility of an option based on a specific
#'   type of prospect theory. For details see \link{v_wrapper} and
#'   \link{w_wrapper}.
#'
#'
#' @param opt numeric vector specifying the outcomes and probabilities of an
#'   option. The function expects a length of (number of outcomes * 2 + 1),
#'   that is ordered according to max_loss, min_loss, max_gain, min_gain, and
#'   whose last entry indicates the number of loss outcomes.
#' @param par numeric vector specifying the parameters of the CPT model. See
#'   \link{v_wrapper} and \link{v_wrapper}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a utility.
#'
#' @export
utility <- function(opt, par, type) {
    .Call('choicepp_utility', PACKAGE = 'choicepp', opt, par, type)
}

#' Exponential choice rule
#'
#' \code{choice_rule} calculates the probability of choosing A using an ex-
#'   ponential choice rule.
#'
#' @param utA numeric specifying the utility of option A
#' @param utB numeric specifying the utility of option B
#' @param phi numeric specifying the choice sensitivity
#'
#' @return a choice probability
#'
#' @export
choice_rule <- function(utA, utB, phi) {
    .Call('choicepp_choice_rule', PACKAGE = 'choicepp', utA, utB, phi)
}

#' CPT-based choice probabilities
#'
#' \code{cpt_prob} computes for a set of choice problems and a set of
#'   parameters the respective probabilities of choosing option A.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
#'
#' @return a vector of choice probabilities
#'
#' @export
cpt_prob <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_prob', PACKAGE = 'choicepp', par, problems, type)
}

#' CPT-based likelihood
#'
#' \code{cpt_prob} computes for a set of choice problems and a set of
#'   parameters the combined (negative) log-likelihood of a set of choices.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems list as generated by \link{p_arrange}.
#' @param choices numeric vector of 0s and 1s indicating the choices where
#'   0 = A and 0 = B.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
#'
#' @return a vector of choice probabilities
#'
#' @export
cpt_lik <- function(par, problems, choices, type = 000L, limit = .0001) {
    .Call('choicepp_cpt_lik', PACKAGE = 'choicepp', par, problems, choices, type, limit)
}

#' CPT-based deterministic choices
#'
#' \code{cpt_choice} produces deterministic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
#'
#' @return a vector of choices
#'
#' @export
cpt_choice <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_choice', PACKAGE = 'choicepp', par, problems, type)
}

#' CPT-based probabilistic choices
#'
#' \code{cpt_rndchoice} produces probabilistic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
#'
#' @return a vector of choices
#'
#' @export
cpt_rndchoice <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_rndchoice', PACKAGE = 'choicepp', par, problems, type)
}

#' CPT-based probabilistic choices plus certainty effect
#'
#' \code{cpt_rndchoice} produces probabilistic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
#'
#' @return a vector of choices
#'
#' @export
cpt_rndchoice_cert <- function(par, problems, type = 000L) {
    .Call('choicepp_cpt_rndchoice_cert', PACKAGE = 'choicepp', par, problems, type)
}

#' Expo 1
#'
NULL

#' Expo 2
#'
NULL

#' Hyper 1
#'
NULL

#' Hyper 2
#'
NULL

#' Exponential choice rule
#'
#' Exponential choice rule is defined as
#' \eqn{p_ss = \frac{1}{1 + e^{\phi * (u_ll - u_ss)}}}
#'
#' @param diff difference in utility between sooner smaller
#'   and larger later options.
#' @param phi sensitivity parameter.
#'
#' @return Probability to choose sooner smaller option \eqn{p_ss}.
#'
#' @export
expo_rule <- function(diff, phi) {
    .Call('choicepp_expo_rule', PACKAGE = 'choicepp', diff, phi)
}

#' Homothetic choice rule
#'
#' Homothetic choice rule is defined as
#' \eqn{p_ss = \frac{u_ss^\phi}{u_ss^\phi + u_ll^\phi}}
#'
#' @param u_ss utility of sooner smaller option.
#' @param u_ll utility of larger later option.
#' @param phi sensitivity parameter.
#'
#' @return Probability to choose sooner smaller option \eqn{p_ss}.
#'
#' @export
homo_rule <- function(u_ss, u_ll, phi) {
    .Call('choicepp_homo_rule', PACKAGE = 'choicepp', u_ss, u_ll, phi)
}

#' EXPO likelihood
#'
#' Likelihood function for various exponential discounting models.
#'
#' Function takes parameter values, the choice problem, and the actual choices
#' to compute a likelihood of the choices given the parameters.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements \eqn{k^delay} variant with exponential choice rule
#'
#' 01 implements \eqn{k^delay} variant with homothetic choice rule
#'
#' 10 implements \eqn{e^{-k*delay}} variant with exponential choice rule
#'
#' 11 implements \eqn{e^{-k*delay}} variant with homothetic choice rule
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param choices numeric vector containing the choice choice (0 = sooner smaller,
#'   1 = larger later).
#' @param epsilon numeric scalar specifying a boundary on the likelihood of a choice.
#'   Specifically, likelihoods will be bound between epsilon and 1-epsilon.
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return The negative log-liklihood XXX.
#'
#' @export
EXPO_lik <- function(par, problems, choices, epsilon = .0001, type = 00L) {
    .Call('choicepp_EXPO_lik', PACKAGE = 'choicepp', par, problems, choices, epsilon, type)
}

#' EXPO deterministic choices
#'
#' Generate deterministic choice from various exponential discounting models.
#'
#' Function takes parameter values and the choice problem to generate
#' deterministic choices.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements \eqn{k^delay} variant with exponential choice rule
#'
#' 01 implements \eqn{k^delay} variant with homothetic choice rule
#'
#' 10 implements \eqn{e^{k*delay}} variant with exponential choice rule
#'
#' 11 implements \eqn{e^{k*delay}} variant with homothetic choice rule
#'
#'
#' Note that for deterministic choice 00 = 01 and 10 = 11, i.e., choice rules
#' become irrelevant.
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param type integer specifying the model variant to be used. See details.
#' @param random logical specifiyng whether ties should lead to NA (here -1) or
#'   random choice.
#'
#' @return A vector of choices.
#'
#' @export
EXPO_choice <- function(par, problems, type, random = FALSE) {
    .Call('choicepp_EXPO_choice', PACKAGE = 'choicepp', par, problems, type, random)
}

#' EXPO random choices
#'
#' Generate random choice from various exponential discounting models.
#'
#' Function takes parameter values and the choice problem to generate
#' deterministic choices.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements \eqn{k^delay} variant with exponential choice rule
#'
#' 01 implements \eqn{k^delay} variant with homothetic choice rule
#'
#' 10 implements \eqn{e^{k*delay}} variant with exponential choice rule
#'
#' 11 implements \eqn{e^{k*delay}} variant with homothetic choice rule
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param type integer specifying the model variant to be used. See details.
#' @return A vector of choices.
#'
#' @export
EXPO_rndchoice <- function(par, problems, type = 00L) {
    .Call('choicepp_EXPO_rndchoice', PACKAGE = 'choicepp', par, problems, type)
}

#' EXPO probabilities
#'
#' Generate predicted choice probabilities from exponential discounting model with
#' exponential choice rule.
#'
#' Function takes parameter values and the choice problem to generate
#' probabilistic predictions.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements \eqn{k^delay} variant with exponential choice rule
#'
#' 01 implements \eqn{k^delay} variant with homothetic choice rule
#'
#' 10 implements \eqn{e^{k*delay}} variant with exponential choice rule
#'
#' 11 implements \eqn{e^{k*delay}} variant with homothetic choice rule
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return A vector of choice probabilities.
#'
#' @export
EXPO_prob <- function(par, problems, type = 00L) {
    .Call('choicepp_EXPO_prob', PACKAGE = 'choicepp', par, problems, type)
}

#' HYPER likelihood
#'
#' Likelihood function for various hyperbolic discounting models.
#'
#' Function takes parameter values, the choice problem, and the actual choices
#' to compute a likelihood of the choices given the parameters.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements the one parameter variant with exponential choice rule
#'
#' 01 implements the one parameter variant with homothetic choice rule
#'
#' 10 implements the two parameter variant with exponential choice rule
#'
#' 11 implements the two parameter variant with homothetic choice rule
#'
#'
#' The delay of the one parameter variant is modeled as
#' \deqn{1.0 / (1.0 + k * delay)}
#'
#' and that of the two parameter variant is modeled as
#' \eqn{(1.0 / (1.0 + k * delay))^s}
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param choices numeric vector containing the choice choice (0 = sooner smaller,
#'   1 = larger later).
#' @param epsilon numeric scalar specifying a boundary on the likelihood of a choice.
#'   Specifically, likelihoods will be bound between epsilon and 1-epsilon.
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return The negative log-liklihood.
#'
#' @export
HYPER_lik <- function(par, problems, choices, epsilon = .0001, type = 00L) {
    .Call('choicepp_HYPER_lik', PACKAGE = 'choicepp', par, problems, choices, epsilon, type)
}

#' HYPER deterministic choices
#'
#' Generate deterministic choice from various hyperbolic discounting models.
#'
#' Function takes parameter values and the choice problem to generate
#' deterministic choices.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements the one parameter variant with exponential choice rule
#'
#' 01 implements the one parameter variant with homothetic choice rule
#'
#' 10 implements the two parameter variant with exponential choice rule
#'
#' 11 implements the two parameter variant with homothetic choice rule
#'
#'
#' The delay of the one parameter variant is modeled as
#' \deqn{1.0 / (1.0 + k * delay)}
#'
#' and that of the two parameter variant is modeled as
#' \eqn{(1.0 / (1.0 + k * delay))^s}
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param type integer specifying the model variant to be used. See details.
#' @param random logical specifiyng whether ties should lead to NA (here -1) or
#'   random choice.
#'
#' @return A vector of choices.
#'
#' @export
HYPER_choice <- function(par, problems, type = 00L, random = FALSE) {
    .Call('choicepp_HYPER_choice', PACKAGE = 'choicepp', par, problems, type, random)
}

#' HYPER random choices
#'
#' Generate random choice from various hyperbolic discounting models.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements the one parameter variant with exponential choice rule
#'
#' 01 implements the one parameter variant with homothetic choice rule
#'
#' 10 implements the two parameter variant with exponential choice rule
#'
#' 11 implements the two parameter variant with homothetic choice rule
#'
#'
#' The delay of the one parameter variant is modeled as
#' \deqn{1.0 / (1.0 + k * delay)}
#'
#' and that of the two parameter variant is modeled as
#' \eqn{(1.0 / (1.0 + k * delay))^s}
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return A vector of choices.
#'
#' @export
HYPER_rndchoice <- function(par, problems, type = 00L) {
    .Call('choicepp_HYPER_rndchoice', PACKAGE = 'choicepp', par, problems, type)
}

#' HYPER probabilities
#'
#' Generate predicted choice probabilities from various hyperbolic
#' discounting models.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements the one parameter variant with exponential choice rule
#'
#' 01 implements the one parameter variant with homothetic choice rule
#'
#' 10 implements the two parameter variant with exponential choice rule
#'
#' 11 implements the two parameter variant with homothetic choice rule
#'
#'
#' The delay of the one parameter variant is modeled as
#' \deqn{1.0 / (1.0 + k * delay)}
#'
#' and that of the two parameter variant is modeled as
#' \eqn{(1.0 / (1.0 + k * delay))^s}
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return A vector of choice probabilities.
#'
#' @export
HYPER_prob <- function(par, problems, type = 00L) {
    .Call('choicepp_HYPER_prob', PACKAGE = 'choicepp', par, problems, type)
}

#' ITCH 4
#'
#' @export
itch_4 <- function(problem, par) {
    .Call('choicepp_itch_4', PACKAGE = 'choicepp', problem, par)
}

#' ITCH 5
#'
#' @export
itch_5 <- function(problem, par) {
    .Call('choicepp_itch_5', PACKAGE = 'choicepp', problem, par)
}

#' ITCH data
#'
#' Generates matrix containing the four variables needed to compute
#' the ITCH.
#'
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#'
#' @return Four column matrix containing the difference in outcomes, the differences
#' in outcomes normalized by the mean of outcomes, the difference in delays, and the
#' difference in delays normalized by the mean of delays.
#'
#' @export
ITCH_pgen <- function(problems) {
    .Call('choicepp_ITCH_pgen', PACKAGE = 'choicepp', problems)
}

#' ITCH deterministic choices
#'
#' Generate deterministic choice from various intertemporal choice heuristics (ITCH).
#'
#' Function takes parameter values and the choice problem to generate
#' deterministic choices.
#'
#' Functions implements different variants as a function of \code{type}:
#'
#' 00 implements the four parameter variant with exponential choice rule
#'
#' 10 implements the five parameter variant with exponential choice rule
#'
#'
#' The four and five parameter variants are defined as
#' \deqn{\beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#' and
#'
#' \deqn{\beta_5 +
#'       \beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#'
#' With o_ss, o_ll, d_ss, d_ll being the outcomes and delays of the
#' sooner smaller and larger later options, respectively, and o* and d*
#' are the arithmetic means of both outcomes and delays, respectively.
#'
#' Note that the ITCH cannot be used with a homothetic choice rule.
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param choices numeric vector containing the choice choice (0 = sooner smaller,
#'   1 = larger later).
#' @param epsilon numeric scalar specifying a boundary on the likelihood of a choice.
#'   Specifically, likelihoods will be bound between epsilon and 1-epsilon.
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return The negative log-liklihood.
#'
#' @export
ITCH_lik <- function(par, problems, choices, epsilon = .0001, type = 00L) {
    .Call('choicepp_ITCH_lik', PACKAGE = 'choicepp', par, problems, choices, epsilon, type)
}

#' ITCH deterministic choices
#'
#' Generate deterministic choice from various intertemporal choice heuristics (ITCH).
#'
#' Function takes parameter values and the choice problem to generate
#' deterministic choices.
#'
#' Functions implements different model variants as a function of \code{type}:
#'
#' 00 implements the four parameter variant with exponential choice rule
#'
#' 10 implements the five parameter variant with exponential choice rule
#'
#'
#' The four and five parameter variants are defined as
#' \deqn{\beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#' and
#'
#' \deqn{\beta_5 +
#'       \beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#'
#' With o_ss, o_ll, d_ss, d_ll being the outcomes and delays of the
#' sooner smaller and larger later options, respectively, and o* and d*
#' are the arithmetic means of both outcomes and delays, respectively.
#'
#' Note that the ITCH cannot be used with a homothetic choice rule.
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param choices numeric vector containing the choice choice (0 = sooner smaller,
#'   1 = larger later).
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return A vector of choices.
#'
#' @export
ITCH_choice <- function(par, problems, type = 00L, random = FALSE) {
    .Call('choicepp_ITCH_choice', PACKAGE = 'choicepp', par, problems, type, random)
}

#' ITCH random choices
#'
#' Generate random choice from various intertemporal choice heuristics (ITCH).
#'
#' Function takes parameter values and the choice problem to generate
#' random choices.
#'
#' Functions implements different model variants as a function of \code{type}:
#'
#' 00 implements the four parameter variant with exponential choice rule
#'
#' 10 implements the five parameter variant with exponential choice rule
#'
#'
#' The four and five parameter variants are defined as
#' \deqn{\beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#' and
#'
#' \deqn{\beta_5 +
#'       \beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#'
#' With o_ss, o_ll, d_ss, d_ll being the outcomes and delays of the
#' sooner smaller and larger later options, respectively, and o* and d*
#' are the arithmetic means of both outcomes and delays, respectively.
#'
#' Note that the ITCH cannot be used with a homothetic choice rule.
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param choices numeric vector containing the choice choice (0 = sooner smaller,
#'   1 = larger later).
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return A vector of choices.
#'
#' @export
ITCH_rndchoice <- function(par, problems, type = 00L) {
    .Call('choicepp_ITCH_rndchoice', PACKAGE = 'choicepp', par, problems, type)
}

#' ITCH probabilities
#'
#' Generate predicted choice probabilities from variants of the intertemporal
#' choice heuristic (ITCH).
#'
#' Function takes parameter values and the choice problem to generate
#' random choices.
#'
#' Functions implements different model variants as a function of \code{type}:
#'
#' 00 implements the four parameter variant with exponential choice rule
#'
#' 10 implements the five parameter variant with exponential choice rule
#'
#'
#' The four and five parameter variants are defined as
#' \deqn{\beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#' and
#'
#' \deqn{\beta_5 +
#'       \beta_0 * (o_ss - o_ll) + \beta_1 * \frac{o_ss - o_ll}{o*} +
#'       \beta_2 * (d_ss - d_ll) + \beta_3 * \frac{d_ss - d_ll}{d*}}
#'
#' With o_ss, o_ll, d_ss, d_ll being the outcomes and delays of the
#' sooner smaller and larger later options, respectively, and o* and d*
#' are the arithmetic means of both outcomes and delays, respectively.
#'
#' Note that the ITCH cannot be used with a homothetic choice rule.
#'
#' @param par numeric vector specifying the discounting factor
#'   and the choice sensitivity (in that order).
#' @param problems a numeric matrix with four columns containing for each decision
#'   the outcome and delay of the sooner smaller option, the outcome and delay
#'   of the larger later option (in that order).
#' @param choices numeric vector containing the choice choice (0 = sooner smaller,
#'   1 = larger later).
#' @param type integer specifying the model variant to be used. See details.
#'
#' @return A vector of choices.
#'
#' @export
ITCH_prob <- function(par, problems, type = 00L) {
    .Call('choicepp_ITCH_prob', PACKAGE = 'choicepp', par, problems, type)
}

#' Compute natural mean
#'
#' @export
nm <- function(oo) {
    .Call('choicepp_nm', PACKAGE = 'choicepp', oo)
}

#' Compute natural mean
#'
#' @export
nm_long <- function(opt, out, extr = FALSE) {
    .Call('choicepp_nm_long', PACKAGE = 'choicepp', opt, out, extr)
}

#' Compute natural mean
#'
#' @export
nm_rand <- function(oo, phi) {
    .Call('choicepp_nm_rand', PACKAGE = 'choicepp', oo, phi)
}

#' Compute natural mean
#'
#' @export
nms <- function(ss, phi) {
    .Call('choicepp_nms', PACKAGE = 'choicepp', ss, phi)
}

#' Compute natural mean ignoring first experiences
#'
#' @export
nm_rec_rand <- function(oo, phi, ignore) {
    .Call('choicepp_nm_rec_rand', PACKAGE = 'choicepp', oo, phi, ignore)
}

#' Compute natural mean with recency
#'
#' @export
nms_rec <- function(ss, phi, ignore) {
    .Call('choicepp_nms_rec', PACKAGE = 'choicepp', ss, phi, ignore)
}

#' Compute round wise
#'
#' @export
rw <- function(opt, out, extr = FALSE) {
    .Call('choicepp_rw', PACKAGE = 'choicepp', opt, out, extr)
}

#' Compute round wise
#'
#' @export
si <- function(opt, out, w, extr = FALSE, verbose = FALSE) {
    .Call('choicepp_si', PACKAGE = 'choicepp', opt, out, w, extr, verbose)
}

#' Compute round wise
#'
#' @export
si2 <- function(opt, out, w, extr = FALSE, verbose = FALSE) {
    .Call('choicepp_si2', PACKAGE = 'choicepp', opt, out, w, extr, verbose)
}

#' Compute round wise
#'
#' @export
si3 <- function(opt, out, w, extr = FALSE, verbose = FALSE) {
    .Call('choicepp_si3', PACKAGE = 'choicepp', opt, out, w, extr, verbose)
}

dbinomC200 <- function(k, n, p) {
    .Call('choicepp_dbinomC200', PACKAGE = 'choicepp', k, n, p)
}

dbinomC <- function(k, n, p, nlookup, root) {
    .Call('choicepp_dbinomC', PACKAGE = 'choicepp', k, n, p, nlookup, root)
}

#' Test for 1st order stochastic dominance
#'
#' \code{stdom1} tests if one of two problems is stochastically dominant
#'   according to 1st order stochastic dominance.
#'
#' @param A numeric vector containing the outcomes and probabilities
#'   (in that order) of option A
#' @param B numeric vector containing the outcomes and probabilities
#'   (in that order) of option B
#'
#' @return A boolean indicating the status of 1st order stochastic dominance
#'
#' @export
stdom1 <- function(oA, pA, oB, pB) {
    .Call('choicepp_stdom1', PACKAGE = 'choicepp', oA, pA, oB, pB)
}

#' Test for 2nd order stochastic dominance
#'
#' \code{stdom2} tests if one of two problems is stochastically dominant
#'   according to 2nd order stochastic dominance.
#'
#' @param A numeric vector containing the outcomes and probabilities
#'   (in that order) of option A
#' @param B numeric vector containing the outcomes and probabilities
#'   (in that order) of option B
#'
#' @return A boolean indicating the status of 2nd order stochastic dominance
#'
#' @export
stdom2 <- function(oA, pA, oB, pB, d_crit = 0) {
    .Call('choicepp_stdom2', PACKAGE = 'choicepp', oA, pA, oB, pB, d_crit)
}

#' Generate random decision environments
#'
#' \code{pgen_rnd} generates random environments of twp-option choice
#'   problems without 1st and 2nd order stochastic dominance and an
#'   ecologically
#'
#' @param ns integer vector of length three specifying the number of choice
#'   problems in the domain of Gain, Loss, and Mixed (in that order).
#' @param nA integer specifying the number of outcomes in option A
#' @param nB integer specifying the number of outcomes in option B
#' @param lower integer specifying the lower limit of the outcome range
#' @param upper integer specifying the upper limit of the outcome range
#' @param ecological bool specifies whether the outomes should be re-
#'   arranged such that high outcomes are coupled with low probabilities
#' @param stdom1_test bool specifies wehther the function controls for 1st oder
#'   stochastic dominance. If true, only non-dominant problems will be
#'   returned.
#' @param stdom1_test bool specifies wehther the function controls for 2nd oder
#'   stochastic dominance. If true, only non-dominant problems will be
#'   returned.
#' @param d_crit double specifiying the maximum effect size between the options.
#'     I.e., a d_crit value of .5 implies that options differences in
#'     expected values is at most .5 times the pooled standard deviation.
#'
#' @return A matrix of choice problems
#'
#' @export
pgen_rnd <- function(ns, nA = 2L, nB = 2L, lower = -100, upper = 100, ecological = TRUE, stdom1_test = TRUE, stdom2_test = TRUE, d_crit = .5) {
    .Call('choicepp_pgen_rnd', PACKAGE = 'choicepp', ns, nA, nB, lower, upper, ecological, stdom1_test, stdom2_test, d_crit)
}

#' Rearrange problems
#'
#' \code{p_arrange} rearranges the matrix of problem to match the cumulative and
#'   decumulative specifications of CPT and TAX
#'
#' @param problems np x (2*nA + 2*nB) matrix containing the np problems each
#'   having nA and nB outcomes.
#' @param nA number of outcomes in option A
#'
#' @return a list of two matrices containing the outcomes and probabilities of
#'   the A and B options rearranged for CPT and TAX.
#'
#' @export
p_arrange <- function(problems, nA = 0L) {
    .Call('choicepp_p_arrange', PACKAGE = 'choicepp', problems, nA)
}

#' Generate delay discounting problems
#'
#' Generate random delay discounting problems.
#'
#' Algorithm draws two outcomes and two delays and then
#' maps the smaller outcome to the smaller delay and the larger
#' outcome to the larger delay.
#'
#' Values are drawn from uniform.
#'
#' @param n_problem integer specifying the number of problems.
#' @param o_lower integer specifying the smalles possible outcome.
#' @param o_upper integer specifying the largest possible outcome.
#' @param d_lower integer specifying the smalles possible delay.
#' @param d_upper integer specifying the smalles possible delay.
#'
#' @return Four column matrix containing for each problem
#'   the outcome and delay of the sooner smaller option and the outcome and delay
#'   of the larger later option (in that order).
#'
#' @export
pgen_dd <- function(n_problem, o_lower = 0, o_upper = 100, d_lower = 0, d_upper = 100) {
    .Call('choicepp_pgen_dd', PACKAGE = 'choicepp', n_problem, o_lower, o_upper, d_lower, d_upper)
}

reduce_option <- function(opt, has_n = FALSE) {
    .Call('choicepp_reduce_option', PACKAGE = 'choicepp', opt, has_n)
}

sort_by_p <- function(opt, has_n = TRUE) {
    .Call('choicepp_sort_by_p', PACKAGE = 'choicepp', opt, has_n)
}

bayes_mean <- function(opt_A, opt_B) {
    .Call('choicepp_bayes_mean', PACKAGE = 'choicepp', opt_A, opt_B)
}

natural_mean <- function(opt_A, opt_B) {
    .Call('choicepp_natural_mean', PACKAGE = 'choicepp', opt_A, opt_B)
}

equiprobable <- function(opt_A, opt_B) {
    .Call('choicepp_equiprobable', PACKAGE = 'choicepp', opt_A, opt_B)
}

minimax <- function(opt_A, opt_B) {
    .Call('choicepp_minimax', PACKAGE = 'choicepp', opt_A, opt_B)
}

maximax <- function(opt_A, opt_B) {
    .Call('choicepp_maximax', PACKAGE = 'choicepp', opt_A, opt_B)
}

minimax_regret <- function(opt_A, opt_B) {
    .Call('choicepp_minimax_regret', PACKAGE = 'choicepp', opt_A, opt_B)
}

payoffelimination <- function(opt_A, opt_B) {
    .Call('choicepp_payoffelimination', PACKAGE = 'choicepp', opt_A, opt_B)
}

betterthanaverage <- function(opt_A, opt_B) {
    .Call('choicepp_betterthanaverage', PACKAGE = 'choicepp', opt_A, opt_B)
}

mostlikely <- function(opt_A, opt_B) {
    .Call('choicepp_mostlikely', PACKAGE = 'choicepp', opt_A, opt_B)
}

leastlikely <- function(opt_A, opt_B) {
    .Call('choicepp_leastlikely', PACKAGE = 'choicepp', opt_A, opt_B)
}

probable <- function(opt_A, opt_B, p_limit = .5) {
    .Call('choicepp_probable', PACKAGE = 'choicepp', opt_A, opt_B, p_limit)
}

exppayoffelimination <- function(opt_A, opt_B) {
    .Call('choicepp_exppayoffelimination', PACKAGE = 'choicepp', opt_A, opt_B)
}

lexicographic <- function(opt_A, opt_B) {
    .Call('choicepp_lexicographic', PACKAGE = 'choicepp', opt_A, opt_B)
}

toolbox <- function(prob) {
    .Call('choicepp_toolbox', PACKAGE = 'choicepp', prob)
}

rnorm_cpp <- function(mu, sigma) {
    .Call('choicepp_rnorm_cpp', PACKAGE = 'choicepp', mu, sigma)
}

arrange_pos <- function(opt) {
    .Call('choicepp_arrange_pos', PACKAGE = 'choicepp', opt)
}

edit_pos <- function(ss, opt, add_n = FALSE, do_arrange = TRUE) {
    .Call('choicepp_edit_pos', PACKAGE = 'choicepp', ss, opt, add_n, do_arrange)
}

#' Edit experiences
#'
#' \code{edit_exp} converts the collected samples into a problem table of
#'   the same format as the original problem table. See link{p_arrange}.
#'
#' @param ss a list of samples as generated by, e.g., \link{sampl_n}.
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param frequency
#'
#' @return a problem table matching \code{prob}.
#'
#' @export
edit_exp_pos <- function(ss, prob, add_n = FALSE, do_arrange = TRUE) {
    .Call('choicepp_edit_exp_pos', PACKAGE = 'choicepp', ss, prob, add_n, do_arrange)
}

#' Calculate the utility of an option
#'
#' \code{utility} calculates the utility of an option based on a specific
#'   type of prospect theory. For details see \link{v_wrapper} and
#'   \link{w_wrapper}.
#'
#'
#' @param opt numeric vector specifying the outcomes and probabilities of an
#'   option. The function expects a length of (number of outcomes * 2 + 1),
#'   that is ordered according to max_loss, min_loss, max_gain, min_gain, and
#'   whose last entry indicates the number of loss outcomes.
#' @param par numeric vector specifying the parameters of the CPT model. See
#'   \link{v_wrapper} and \link{v_wrapper}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{v_wrapper}.
#'
#' @return a utility.
#'
#' @export
utility_pos <- function(opt, par, type, noise_level, recency) {
    .Call('choicepp_utility_pos', PACKAGE = 'choicepp', opt, par, type, noise_level, recency)
}

#' CPT-based deterministic choices
#'
#' \code{cpt_choice} produces deterministic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the value and
#'   weighting function. See \link{v_wrapper} and \link{w_wrapper}.
#'
#' @return a vector of choices
#'
#' @export
cpt_choice_pos <- function(par, problems, type = 000L, noise_level = 0, recency = 0) {
    .Call('choicepp_cpt_choice_pos', PACKAGE = 'choicepp', par, problems, type, noise_level, recency)
}

#' Get standard deviation
#'
#' \code{getSD} iterates over the samples of a problem and returns the
#'   standard for the problem (relative to mean of all outcomes across
#'   both problems).
#'
#' @param ss numeric specifying the to be transformed probability.
#'
#' @return the standard deviation of the problem.
#'
#' @export
getSD <- function(ss) {
    .Call('choicepp_getSD', PACKAGE = 'choicepp', ss)
}

#' Add noise to experienced samples.
#'
#' \code{addNoise} takes the sampled and edited and adds noise based on the
#'   prevalence reconstructed from the sample size and probability to each
#'   of the outcomes based on the provided standard deviation and \code{k}.
#'
#' @param problems edited experiences as provided by \link{editExp}.
#' @param size vector of integer specifying the sample size for each of the
#'   problems.
#' @param sds vector of doubles specifying the standard deviation for each
#'   of the problems.
#' @param k double specifying a multiplicative factor of the standard
#'   deviation.
#'
#' @return problems with added noise
#'
#' @export
addNoise <- function(problems, sds, k) {
    .Call('choicepp_addNoise', PACKAGE = 'choicepp', problems, sds, k)
}

#' Add noise to experienced samples.
#'
#' \code{addNoise} takes the sampled and edited and adds noise based on the
#'   prevalence reconstructed from the sample size and probability to each
#'   of the outcomes based on the provided standard deviation and \code{k}.
#'
#' @param problems edited experiences as provided by \link{editExp}.
#' @param size vector of integer specifying the sample size for each of the
#'   problems.
#' @param sds vector of doubles specifying the standard deviation for each
#'   of the problems.
#' @param k double specifying a multiplicative factor of the standard
#'   deviation.
#'
#' @return problems with added noise
#'
#' @export
addPositionWeighting <- function(problems, phi, sds, k) {
    .Call('choicepp_addPositionWeighting', PACKAGE = 'choicepp', problems, phi, sds, k)
}

submean <- function(x, a, b) {
    .Call('choicepp_submean', PACKAGE = 'choicepp', x, a, b)
}

recency_wos <- function(oo, choice) {
    .Call('choicepp_recency_wos', PACKAGE = 'choicepp', oo, choice)
}

#' Compute recency effect
#'
#' @export
recency <- function(ss, choices) {
    .Call('choicepp_recency', PACKAGE = 'choicepp', ss, choices)
}

edit <- function(ss, opt, add_n = FALSE, do_arrange = TRUE) {
    .Call('choicepp_edit', PACKAGE = 'choicepp', ss, opt, add_n, do_arrange)
}

#' Edit experiences
#'
#' \code{edit_exp} converts the collected samples into a problem table of
#'   the same format as the original problem table. See link{p_arrange}.
#'
#' @param ss a list of samples as generated by, e.g., \link{sampl_n}.
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param frequency
#'
#' @return a problem table matching \code{prob}.
#'
#' @export
edit_exp <- function(ss, prob, add_n = FALSE, do_arrange = TRUE) {
    .Call('choicepp_edit_exp', PACKAGE = 'choicepp', ss, prob, add_n, do_arrange)
}

smpl <- function(opt) {
    .Call('choicepp_smpl', PACKAGE = 'choicepp', opt)
}

smpl_f <- function(opt) {
    .Call('choicepp_smpl_f', PACKAGE = 'choicepp', opt)
}

smpl_n <- function(opt, n) {
    .Call('choicepp_smpl_n', PACKAGE = 'choicepp', opt, n)
}

#' Sample a fixed number of outcomes per option
#'
#' \code{sampl_n} draws a fixed number of samples for each option in the
#'   set of problems.
#'
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param ns numceric vector whose length is either one or the number of
#'   problems in the set.
#'
#' @return a list of samples.
#'
#' @export
sampl_n <- function(prob, ns) {
    .Call('choicepp_sampl_n', PACKAGE = 'choicepp', prob, ns)
}

smpl_easy <- function(a, b, phi, par, type) {
    .Call('choicepp_smpl_easy', PACKAGE = 'choicepp', a, b, phi, par, type)
}

#' Sampling algorithm using stop when easy stopping rule
#'
#' \code{smpl_easy} implements a sampling process that terminates sampling
#'   increasingly likely as the distance between the options becomes large
#'
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param ns numceric vector whose length is either one or the number of
#'   problems in the set.
#' @param phi a numeric specifying the sensitivity to the difference in
#'   option utilities. Large numbers result in early search termination.
#' @param par a numeric vector to be passed on to \link{utility}.
#' @param type an integer to be passed on to \link{utility}.
#'
#'
#' @return a list of witch each element containing the samples for option
#'   A, the samples for option B, and the choice.
#'
#' @export
sampl_easy <- function(prob, phi, par, type) {
    .Call('choicepp_sampl_easy', PACKAGE = 'choicepp', prob, phi, par, type)
}

smpl_even <- function(a, b, gamma_eq, gamma_uneq) {
    .Call('choicepp_smpl_even', PACKAGE = 'choicepp', a, b, gamma_eq, gamma_uneq)
}

#' Sampling algorithm using a stop when even stopping rule
#'
#' \code{sample_even} implements a sampling process that terminates more
#'   likly when equally many outcomes in both options have been experienced.
#'
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param gamma_eq a numeric controlling the likelihood with which search
#'   stops in the case of equally many experienced outcomes. Large number
#'   result in early search termination
#' @param gamma_uneq a numeric controlling the likelihood with which search
#'   stops in the case of equally many experienced outcomes. Large numbers
#'   result in early search termination.
#'
#' @return a list of witch each element containing the samples for option
#'   A, the samples for option B, and the choice.
#'
#' @export
sampl_even <- function(prob, gamma_eq, gamma_uneq) {
    .Call('choicepp_sampl_even', PACKAGE = 'choicepp', prob, gamma_eq, gamma_uneq)
}

get_nout <- function(prob) {
    .Call('choicepp_get_nout', PACKAGE = 'choicepp', prob)
}

get_minn <- function(prob) {
    .Call('choicepp_get_minn', PACKAGE = 'choicepp', prob)
}

smpl_complete <- function(a, b, n, gamma_compl, gamma_incompl) {
    .Call('choicepp_smpl_complete', PACKAGE = 'choicepp', a, b, n, gamma_compl, gamma_incompl)
}

smpl_complete2 <- function(a, b, n, gamma_compl, gamma_incompl) {
    .Call('choicepp_smpl_complete2', PACKAGE = 'choicepp', a, b, n, gamma_compl, gamma_incompl)
}

#' Sampling algorithm using a stop when complete stopping rule
#'
#' \code{sample_complete} implements a sampling process that terminates more
#'   likly when (at least) an expected number of outcomes has been observed
#'   across both options. The expected number of outcomes is drawn from the
#'   distribution of number of outcomes across the entire problem set.
#'
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param ns numceric vector whose length is either one or the number of
#'   problems in the set.
#' @param gamma_compl a numeric controlling the likelihood with which search
#'   stops in the case of equally many experienced outcomes. Large numbers
#'   result in early search termination.
#' @param gamma_incompl a numeric controlling the likelihood with which
#'   search stops in the case of equally many experienced outcomes. Large
#'   numbers result in early search termination.
#'
#' @return a list of witch each element containing the samples for option
#'   A, the samples for option B, and the choice.
#'
#' @export
sampl_complete <- function(prob, gamma_compl, gamma_incompl) {
    .Call('choicepp_sampl_complete', PACKAGE = 'choicepp', prob, gamma_compl, gamma_incompl)
}

#' Sampling algorithm using a stop when complete stopping rule
#'
#' \code{sample_complete2} implements a sampling process that terminates more
#'   likly when a minimum number of outcomes has been observed across both
#'   options and non-zero outcomes have been observed for both options.
#'   The minimum number of outcomes equals the minimum the distribution of
#'   number of outcomes across the entire problem set.
#'
#' @param prob a problem table as produced by \link{p_arrange}.
#' @param ns numceric vector whose length is either one or the number of
#'   problems in the set.
#' @param gamma_compl a numeric controlling the likelihood with which search
#'   stops in the case of equally many experienced outcomes. Large numbers
#'   result in early search termination.
#' @param gamma_incompl a numeric controlling the likelihood with which
#'   search stops in the case of equally many experienced outcomes. Large
#'   numbers result in early search termination.
#'
#' @return a list of witch each element containing the samples for option
#'   A, the samples for option B, and the choice.
#'
#' @export
sampl_complete2 <- function(prob, gamma_compl, gamma_incompl) {
    .Call('choicepp_sampl_complete2', PACKAGE = 'choicepp', prob, gamma_compl, gamma_incompl)
}

#' Value function of TAX
#'
#' \code{u}, the TAX value function, transforms the magnitute of
#'   an outcome into utility space.
#'
#' @param o numeric specifying the magnitude of the to be transformed
#'   outcome
#' @param alpha numeric specifying the exponent of the utility function for
#'   the gain domain.
#'
#' @return a utility
#'
#' @export
u <- function(o, alpha) {
    .Call('choicepp_u', PACKAGE = 'choicepp', o, alpha)
}

#' Weighting function of TAX
#'
#' \code{t_tax} is the weighting function of TAX.
#'
#' @param p numeric specifying the to be transformed probability.
#' @param gamma numeric specifying the exponential factor
#'   (sensitivity) of the probability weighting function.
#'
#' @return a decision weight
#'
#' @references Birnbaum, M. H. (1999). Testing critical properties of
#'   decision making on the Internet. Psychological Science, 10(5), 399-407.
#'
#' @export
t_tax <- function(p, gamma) {
    .Call('choicepp_t_tax', PACKAGE = 'choicepp', p, gamma)
}

#' Transfer function of TAX
#'
#' \code{w} is the transfer function of TAX.
#'
#' @param pi numeric specifying the to be transformed probability at i.
#' @param pk numeric specifying the to be transformed probability at k.
#' @param delta numeric specifying the transfer factor.
#' @param gamma numeric specifying the exponential factor (sensitivity) of
#'   the probability weighting function. See \link{t_tax}.
#'
#' @return a transfer weight
#'
#' @references Birnbaum, M. H. (1999). Testing critical properties of
#'   decision making on the Internet. Psychological Science, 10(5), 399-407.
#'
#' @export
w <- function(pi, pk, delta, gamma, n) {
    .Call('choicepp_w', PACKAGE = 'choicepp', pi, pk, delta, gamma, n)
}

#' Utility function of TAX
#'
#' \code{utility_tax} is the utility function of TAX, producing utility
#'   values for choice options absed on a given set of parameters.
#'
#' @param opt numeric vector specifying the outcomes and probabilities of an
#'   option. The function expects a length of (number of outcomes * 2 + 1),
#'   that is ordered according to max_loss, min_loss, max_gain, min_gain, and
#'   whose last entry indicates the number of loss outcomes.
#' @param par numeric vector specifying the parameters of the CPT model. See
#'   \link{u}, \link{t_tax}, and \link{w}.
#' @param type integer specifying the parameterization of TAX.
#'   \code{type = 0} is the one parameter TAX with just a \code{gamma}
#'   parameter. \code{type = 1} is the two parameter TAX with a \code{gamma}
#'   and a \code{alpha} parameter. \code{type = 2} is the two parameter TAX
#'   with a \code{gamma} and a \code{delta} parameter. \code{type = 3} is the
#'   three parameter TAX with a \code{gamma}, a \code{alpha}, and a
#'   \code{delta} parameter.
#'
#' @return a utility
#'
#' @references Birnbaum, M. H. (1999). Testing critical properties of
#'   decision making on the Internet. Psychological Science, 10(5), 399-407.
#'
#' @export
utility_tax <- function(opt, par, type) {
    .Call('choicepp_utility_tax', PACKAGE = 'choicepp', opt, par, type)
}

#' TAX-based choice probabilities
#'
#' \code{tax_prob} computes for a set of choice problems and a set of
#'   parameters the respective probabilities of choosing option A.
#'
#' @param par numeric vector specifying the parameters of the TAX model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of tax model. See
#'   \link{utility_tax}.
#'
#' @return a vector of choice probabilities
#'
#' @export
tax_prob <- function(par, problems, type = 1L) {
    .Call('choicepp_tax_prob', PACKAGE = 'choicepp', par, problems, type)
}

#' TAX-based likelihood
#'
#' \code{tax_prob} computes for a set of choice problems and a set of
#'   parameters the combined (negative) log-likelihood of a set of choices.
#'
#' @param par numeric vector specifying the parameters of the TAX model.
#' @param problems list as generated by \link{p_arrange}.
#' @param choices numeric vector of 0s and 1s indicating the choices where
#'   0 = A and 0 = B.
#' @param type integer specifying the parameterization of the tax model. See
#'   \link{utility_tax}.
#'
#' @return a vector of choice probabilities
#'
#' @export
tax_lik <- function(par, problems, choices, type = 1L, limit = .0001) {
    .Call('choicepp_tax_lik', PACKAGE = 'choicepp', par, problems, choices, type, limit)
}

#' TAX-based deterministic choices
#'
#' \code{tax_choice} produces deterministic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the tax model
#'   function. See \link{utility_tax}.
#'
#' @return a vector of choices
#'
#' @export
tax_choice <- function(par, problems, type = 1L) {
    .Call('choicepp_tax_choice', PACKAGE = 'choicepp', par, problems, type)
}

#' TAX-based probabilistic choices
#'
#' \code{tax_rndchoice} produces probabilistic choices for a set of choice
#'   problems and parameters.
#'
#' @param par numeric vector specifying the parameters of the CPT model.
#' @param problems a list as generated by \link{p_arrange}.
#' @param type integer specifying the parameterization of the tax model
#'   function. See \link{utility_tax}.
#'
#' @return a vector of choices
#'
#' @export
tax_rndchoice <- function(par, problems, type = 1L) {
    .Call('choicepp_tax_rndchoice', PACKAGE = 'choicepp', par, problems, type)
}

